package squashfs

import (
	"crypto/md5"
	"fmt"
	"io"
	"os"
	"testing"
	"time"
)

func cmpFileInfo(got os.FileInfo, want FileInfo) error {
	if got, want := got.Name(), want.name; got != want {
		return fmt.Errorf("unexpected file name: got %q, want %q", got, want)
	}
	if got, want := got.Size(), want.size; got != want {
		return fmt.Errorf("unexpected size: got %d, want %d", got, want)
	}
	if got, want := got.IsDir(), want.mode.IsDir(); got != want {
		return fmt.Errorf("IsDir: got %v, want %v", got, want)
	}
	if got, want := got.ModTime(), want.modTime; !got.Equal(want) {
		return fmt.Errorf("IsDir: got %v, want %v", got, want)
	}

	return nil
}

func TestReaddir(t *testing.T) {
	t.Parallel()
	// TODO: ship testdata files generated by mksquashfs
	f, err := os.Open("/home/michael/zi/build/zi/pkg/ack-2.24.squashfs")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	rd, err := NewReader(f)
	if err != nil {
		t.Fatal(err)
	}

	fis, err := rd.Readdir(rd.RootInode())
	if err != nil {
		t.Fatal(err)
	}

	if got, want := len(fis), 2; got != want {
		t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
	}

	if err := cmpFileInfo(fis[0], FileInfo{
		name:    "bin",
		size:    26,
		mode:    0555 | os.ModeDir,
		modTime: time.Unix(1537343074, 0), // stat -c %Y /ro/ack-2.24/bin
	}); err != nil {
		t.Fatal(err)
	}

	if err := cmpFileInfo(fis[1], FileInfo{
		name:    "buildoutput",
		size:    48,
		mode:    0555 | os.ModeDir,
		modTime: time.Unix(1537343072, 0), // stat -c %Y /ro/ack-2.24/buildoutput
	}); err != nil {
		t.Fatal(err)
	}

	fis, err = rd.Readdir(fis[0].Sys().(*FileInfo).Inode)
	if err != nil {
		t.Fatal(err)
	}

	if got, want := len(fis), 1; got != want {
		t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
	}

	if err := cmpFileInfo(fis[0], FileInfo{
		name:    "ack",
		size:    11961,
		mode:    0755,
		modTime: time.Unix(1537343074, 0), // stat -c %Y /ro/ack-2.24/bin/ack
	}); err != nil {
		t.Fatal(err)
	}
}

// TestReaddirSmoke is a smoke-test, reading the root directories of SquashFS
// images which are known to trigger code paths which were buggy.
func TestReaddirSmoke(t *testing.T) {
	t.Parallel()

	for _, fn := range []string{
		// bash exercises the code path where an inode is split across metadata
		// blocks.
		"/home/michael/zi/build/zi/pkg/bash-4.4.18.squashfs",

		// cmake exercises the code path where the root directory entries are
		// located outside of the first block.
		"/home/michael/zi/build/zi/pkg/cmake-3.12.2.squashfs",
	} {
		// TODO: ship testdata files generated by mksquashfs
		f, err := os.Open(fn)
		if err != nil {
			t.Fatal(err)
		}
		defer f.Close()
		rd, err := NewReader(f)
		if err != nil {
			t.Fatal(err)
		}

		fis, err := rd.Readdir(rd.RootInode())
		if err != nil {
			t.Fatal(err)
		}

		if got, want := len(fis), 2; got != want {
			t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
		}
	}
}

func TestReaddirEmpty(t *testing.T) {
	t.Parallel()
	// TODO: ship testdata files generated by mksquashfs
	f, err := os.Open("/home/michael/zi/build/zi/pkg/zlib-1.2.11.squashfs")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	rd, err := NewReader(f)
	if err != nil {
		t.Fatal(err)
	}

	fis, err := rd.Readdir(rd.RootInode())
	if err != nil {
		t.Fatal(err)
	}

	if got, want := len(fis), 2; got != want {
		t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
	}

	if err := cmpFileInfo(fis[0], FileInfo{
		name:    "bin",
		size:    3,
		mode:    0555 | os.ModeDir,
		modTime: time.Unix(1536407741, 0), // stat -c %Y /ro/zlib-1.2.11/bin
	}); err != nil {
		t.Fatal(err)
	}

	fis, err = rd.Readdir(fis[0].Sys().(*FileInfo).Inode)
	if err != nil {
		t.Fatal(err)
	}

	if got, want := len(fis), 0; got != want {
		t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
	}
}

func TestReaddirSymlink(t *testing.T) {
	t.Parallel()
	// TODO: ship testdata files generated by mksquashfs
	f, err := os.Open("/home/michael/zi/build/zi/pkg/zlib-1.2.11.squashfs")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	rd, err := NewReader(f)
	if err != nil {
		t.Fatal(err)
	}

	fis, err := rd.Readdir(rd.RootInode())
	if err != nil {
		t.Fatal(err)
	}

	if got, want := len(fis), 2; got != want {
		t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
	}

	if err := cmpFileInfo(fis[1], FileInfo{
		name:    "buildoutput",
		size:    54,
		mode:    0555 | os.ModeDir,
		modTime: time.Unix(1536407740, 0), // stat -c %Y /ro/zlib-1.2.11/buildoutput
	}); err != nil {
		t.Fatal(err)
	}

	fis, err = rd.Readdir(fis[1].Sys().(*FileInfo).Inode)
	if err != nil {
		t.Fatal(err)
	}

	if got, want := len(fis), 3; got != want {
		t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
	}

	if err := cmpFileInfo(fis[1], FileInfo{
		name:    "lib",
		size:    100,
		mode:    0555 | os.ModeDir,
		modTime: time.Unix(1536407740, 0), // stat -c %Y /ro/zlib-1.2.11/buildoutput/lib
	}); err != nil {
		t.Fatal(err)
	}

	fis, err = rd.Readdir(fis[1].Sys().(*FileInfo).Inode)
	if err != nil {
		t.Fatal(err)
	}

	if got, want := len(fis), 5; got != want {
		t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
	}

	if err := cmpFileInfo(fis[1], FileInfo{
		name:    "libz.so",
		size:    14,
		mode:    0555 | os.ModeSymlink,
		modTime: time.Unix(1536407740, 0), // stat -c %Y /ro/zlib-1.2.11/buildoutput/lib/libz.so
	}); err != nil {
		t.Fatal(err)
	}

	// TODO: readlink
	target, err := rd.ReadLink(fis[1].Sys().(*FileInfo).Inode)
	if err != nil {
		t.Fatal(err)
	}
	if got, want := target, "libz.so.1.2.11"; got != want {
		t.Fatalf("ReadLink(libz.so): got %q, want %q", got, want)
	}
}

func TestReadfile(t *testing.T) {
	t.Parallel()
	// TODO: ship testdata files generated by mksquashfs
	f, err := os.Open("/home/michael/zi/build/zi/pkg/ack-2.24.squashfs")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	rd, err := NewReader(f)
	if err != nil {
		t.Fatal(err)
	}

	fis, err := rd.Readdir(rd.RootInode())
	if err != nil {
		t.Fatal(err)
	}

	if got, want := len(fis), 2; got != want {
		t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
	}

	fis, err = rd.Readdir(fis[0].Sys().(*FileInfo).Inode)
	if err != nil {
		t.Fatal(err)
	}

	if got, want := len(fis), 1; got != want {
		t.Fatalf("unexpected number of directory entries: got %d, want %d", got, want)
	}

	r, err := rd.FileReader(fis[0].Sys().(*FileInfo).Inode)
	if err != nil {
		t.Fatal(err)
	}

	for i := 0; i < 2; i++ {
		if _, err := r.Seek(0, io.SeekStart); err != nil {
			t.Fatal(err)
		}
		h := md5.New()
		if _, err := io.Copy(h, r); err != nil {
			t.Fatal(err)
		}
		sum := fmt.Sprintf("%x", h.Sum(nil))
		if got, want := sum, "bbfc9cdccabfe1a1b9fdb5d1a09ff96d"; got != want {
			t.Fatalf("md5(bin/ack): got %s, want %s", got, want)
		}
	}
}

// TODO: add test exercising ldirInodeHeader, e.g. '/mnt/loop/ca-certificates-3.39/buildoutput/etc/ssl'
