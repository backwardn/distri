// Code generated by protoc-gen-go. DO NOT EDIT.
// source: builder.proto

package builder

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Chunk struct {
	// path is discarded in all but the first Store Chunk message per stream.
	// path is unset in all but the first Retrieve Chunk message per stream.
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Chunk                []byte   `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Chunk) Reset()         { *m = Chunk{} }
func (m *Chunk) String() string { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()    {}
func (*Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_68a5e6cb4f7c8dc9, []int{0}
}

func (m *Chunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Chunk.Unmarshal(m, b)
}
func (m *Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Chunk.Marshal(b, m, deterministic)
}
func (m *Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chunk.Merge(m, src)
}
func (m *Chunk) XXX_Size() int {
	return xxx_messageInfo_Chunk.Size(m)
}
func (m *Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_Chunk proto.InternalMessageInfo

func (m *Chunk) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Chunk) GetChunk() []byte {
	if m != nil {
		return m.Chunk
	}
	return nil
}

type StoreResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoreResponse) Reset()         { *m = StoreResponse{} }
func (m *StoreResponse) String() string { return proto.CompactTextString(m) }
func (*StoreResponse) ProtoMessage()    {}
func (*StoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_68a5e6cb4f7c8dc9, []int{1}
}

func (m *StoreResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StoreResponse.Unmarshal(m, b)
}
func (m *StoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StoreResponse.Marshal(b, m, deterministic)
}
func (m *StoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreResponse.Merge(m, src)
}
func (m *StoreResponse) XXX_Size() int {
	return xxx_messageInfo_StoreResponse.Size(m)
}
func (m *StoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StoreResponse proto.InternalMessageInfo

type RetrieveRequest struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RetrieveRequest) Reset()         { *m = RetrieveRequest{} }
func (m *RetrieveRequest) String() string { return proto.CompactTextString(m) }
func (*RetrieveRequest) ProtoMessage()    {}
func (*RetrieveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_68a5e6cb4f7c8dc9, []int{2}
}

func (m *RetrieveRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RetrieveRequest.Unmarshal(m, b)
}
func (m *RetrieveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RetrieveRequest.Marshal(b, m, deterministic)
}
func (m *RetrieveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetrieveRequest.Merge(m, src)
}
func (m *RetrieveRequest) XXX_Size() int {
	return xxx_messageInfo_RetrieveRequest.Size(m)
}
func (m *RetrieveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RetrieveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RetrieveRequest proto.InternalMessageInfo

func (m *RetrieveRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type BuildRequest struct {
	WorkingDirectory     string   `protobuf:"bytes,1,opt,name=working_directory,json=workingDirectory,proto3" json:"working_directory,omitempty"`
	InputPath            []string `protobuf:"bytes,2,rep,name=input_path,json=inputPath,proto3" json:"input_path,omitempty"`
	BuildFlag            []string `protobuf:"bytes,3,rep,name=build_flag,json=buildFlag,proto3" json:"build_flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildRequest) Reset()         { *m = BuildRequest{} }
func (m *BuildRequest) String() string { return proto.CompactTextString(m) }
func (*BuildRequest) ProtoMessage()    {}
func (*BuildRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_68a5e6cb4f7c8dc9, []int{3}
}

func (m *BuildRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BuildRequest.Unmarshal(m, b)
}
func (m *BuildRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BuildRequest.Marshal(b, m, deterministic)
}
func (m *BuildRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildRequest.Merge(m, src)
}
func (m *BuildRequest) XXX_Size() int {
	return xxx_messageInfo_BuildRequest.Size(m)
}
func (m *BuildRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BuildRequest proto.InternalMessageInfo

func (m *BuildRequest) GetWorkingDirectory() string {
	if m != nil {
		return m.WorkingDirectory
	}
	return ""
}

func (m *BuildRequest) GetInputPath() []string {
	if m != nil {
		return m.InputPath
	}
	return nil
}

func (m *BuildRequest) GetBuildFlag() []string {
	if m != nil {
		return m.BuildFlag
	}
	return nil
}

type BuildProgress struct {
	// Build artifact paths (possibly empty, e.g. in keepalive progress updates),
	// e.g. build/emacs/emacs-amd64-26.2.squashfs.
	OutputPath           []string `protobuf:"bytes,1,rep,name=output_path,json=outputPath,proto3" json:"output_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildProgress) Reset()         { *m = BuildProgress{} }
func (m *BuildProgress) String() string { return proto.CompactTextString(m) }
func (*BuildProgress) ProtoMessage()    {}
func (*BuildProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_68a5e6cb4f7c8dc9, []int{4}
}

func (m *BuildProgress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BuildProgress.Unmarshal(m, b)
}
func (m *BuildProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BuildProgress.Marshal(b, m, deterministic)
}
func (m *BuildProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildProgress.Merge(m, src)
}
func (m *BuildProgress) XXX_Size() int {
	return xxx_messageInfo_BuildProgress.Size(m)
}
func (m *BuildProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildProgress.DiscardUnknown(m)
}

var xxx_messageInfo_BuildProgress proto.InternalMessageInfo

func (m *BuildProgress) GetOutputPath() []string {
	if m != nil {
		return m.OutputPath
	}
	return nil
}

func init() {
	proto.RegisterType((*Chunk)(nil), "builder.Chunk")
	proto.RegisterType((*StoreResponse)(nil), "builder.StoreResponse")
	proto.RegisterType((*RetrieveRequest)(nil), "builder.RetrieveRequest")
	proto.RegisterType((*BuildRequest)(nil), "builder.BuildRequest")
	proto.RegisterType((*BuildProgress)(nil), "builder.BuildProgress")
}

func init() { proto.RegisterFile("builder.proto", fileDescriptor_68a5e6cb4f7c8dc9) }

var fileDescriptor_68a5e6cb4f7c8dc9 = []byte{
	// 295 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x51, 0x5d, 0x4b, 0xc3, 0x40,
	0x10, 0xec, 0xb5, 0x46, 0xed, 0xda, 0x5a, 0x5d, 0x54, 0x42, 0xa1, 0x58, 0x0e, 0x84, 0x80, 0x50,
	0xaa, 0x7d, 0x11, 0x1f, 0x55, 0x7c, 0x2e, 0xe7, 0x0f, 0x08, 0x69, 0xbb, 0xa6, 0xa1, 0x21, 0x17,
	0x2f, 0x17, 0xa5, 0x7f, 0xcb, 0x5f, 0x28, 0xd9, 0x7c, 0xd0, 0x16, 0xdf, 0x6e, 0x67, 0x77, 0x66,
	0x77, 0xe6, 0xa0, 0xbf, 0xc8, 0xa3, 0x78, 0x45, 0x66, 0x92, 0x1a, 0x6d, 0x35, 0x9e, 0x54, 0xa5,
	0x7c, 0x00, 0xe7, 0x75, 0x9d, 0x27, 0x1b, 0x44, 0x38, 0x4a, 0x03, 0xbb, 0x76, 0xc5, 0x58, 0x78,
	0x5d, 0xc5, 0x6f, 0xbc, 0x02, 0x67, 0x59, 0x34, 0xdd, 0xf6, 0x58, 0x78, 0x3d, 0x55, 0x16, 0x72,
	0x00, 0xfd, 0x0f, 0xab, 0x0d, 0x29, 0xca, 0x52, 0x9d, 0x64, 0x24, 0xef, 0x60, 0xa0, 0xc8, 0x9a,
	0x88, 0xbe, 0x49, 0xd1, 0x57, 0x4e, 0x99, 0xfd, 0x4f, 0x4d, 0x6e, 0xa1, 0xf7, 0x52, 0x6c, 0xad,
	0x67, 0xee, 0xe1, 0xf2, 0x47, 0x9b, 0x4d, 0x94, 0x84, 0xfe, 0x2a, 0x32, 0xb4, 0xb4, 0xda, 0x6c,
	0x2b, 0xc2, 0x45, 0xd5, 0x78, 0xab, 0x71, 0x1c, 0x01, 0x44, 0x49, 0x9a, 0x5b, 0x9f, 0x65, 0xdb,
	0xe3, 0x8e, 0xd7, 0x55, 0x5d, 0x46, 0xe6, 0xc5, 0xa5, 0x23, 0x00, 0x76, 0xe4, 0x7f, 0xc6, 0x41,
	0xe8, 0x76, 0xca, 0x36, 0x23, 0xef, 0x71, 0x10, 0xca, 0x29, 0xf4, 0x79, 0xf5, 0xdc, 0xe8, 0xd0,
	0x50, 0x96, 0xe1, 0x2d, 0x9c, 0xe9, 0xdc, 0x36, 0x7a, 0x82, 0x09, 0x50, 0x42, 0x85, 0xe0, 0xe3,
	0xaf, 0x00, 0x87, 0x29, 0x38, 0x03, 0x87, 0xed, 0xe2, 0xf9, 0xa4, 0xce, 0x90, 0x13, 0x1b, 0xde,
	0x34, 0xf5, 0x7e, 0x1c, 0x2d, 0x4f, 0xe0, 0x73, 0xcd, 0xbe, 0x6e, 0x86, 0x76, 0xbd, 0xef, 0x70,
	0xf7, 0xee, 0x92, 0xad, 0xa9, 0xc0, 0x27, 0x38, 0xad, 0xe3, 0x44, 0xb7, 0x99, 0x3b, 0x48, 0x78,
	0x78, 0x70, 0x4d, 0xc1, 0x5c, 0x1c, 0xf3, 0xe7, 0xce, 0xfe, 0x02, 0x00, 0x00, 0xff, 0xff, 0x4e,
	0xa1, 0x5d, 0x5a, 0xed, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BuildClient is the client API for Build service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BuildClient interface {
	// Store persists a file on the builder.
	//
	// Simple implementations might write the file to a directory and clean up
	// files older than a day every hour in a background (e.g. cron) job.
	//
	// Cluster implementations might write the file to a shared network directory
	// (most pragmatic/common), introduce an custom disk abstraction layer (most
	// elegant?) or stickily load-balance via a proxy job (only listed for
	// completeness as it limits build throughput).
	//
	// Cloud implementations might write the file to a key/value store with a TTL
	// of one day.
	//
	// Files are transferred as a stream of chunks with size 4096 bytes.
	Store(ctx context.Context, opts ...grpc.CallOption) (Build_StoreClient, error)
	// Build ensures the specified input_path are available in the current working
	// directory, changes into working_directory, then runs a distri build with
	// any additional build_flag specified.
	//
	// Build output artifacts paths are streamed in BuildProgress messages.
	Build(ctx context.Context, in *BuildRequest, opts ...grpc.CallOption) (Build_BuildClient, error)
	// Retrieve streams the file located at path in chunks of size 4096 bytes.
	Retrieve(ctx context.Context, in *RetrieveRequest, opts ...grpc.CallOption) (Build_RetrieveClient, error)
}

type buildClient struct {
	cc *grpc.ClientConn
}

func NewBuildClient(cc *grpc.ClientConn) BuildClient {
	return &buildClient{cc}
}

func (c *buildClient) Store(ctx context.Context, opts ...grpc.CallOption) (Build_StoreClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Build_serviceDesc.Streams[0], "/builder.Build/Store", opts...)
	if err != nil {
		return nil, err
	}
	x := &buildStoreClient{stream}
	return x, nil
}

type Build_StoreClient interface {
	Send(*Chunk) error
	CloseAndRecv() (*StoreResponse, error)
	grpc.ClientStream
}

type buildStoreClient struct {
	grpc.ClientStream
}

func (x *buildStoreClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *buildStoreClient) CloseAndRecv() (*StoreResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StoreResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *buildClient) Build(ctx context.Context, in *BuildRequest, opts ...grpc.CallOption) (Build_BuildClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Build_serviceDesc.Streams[1], "/builder.Build/Build", opts...)
	if err != nil {
		return nil, err
	}
	x := &buildBuildClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Build_BuildClient interface {
	Recv() (*BuildProgress, error)
	grpc.ClientStream
}

type buildBuildClient struct {
	grpc.ClientStream
}

func (x *buildBuildClient) Recv() (*BuildProgress, error) {
	m := new(BuildProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *buildClient) Retrieve(ctx context.Context, in *RetrieveRequest, opts ...grpc.CallOption) (Build_RetrieveClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Build_serviceDesc.Streams[2], "/builder.Build/Retrieve", opts...)
	if err != nil {
		return nil, err
	}
	x := &buildRetrieveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Build_RetrieveClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type buildRetrieveClient struct {
	grpc.ClientStream
}

func (x *buildRetrieveClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BuildServer is the server API for Build service.
type BuildServer interface {
	// Store persists a file on the builder.
	//
	// Simple implementations might write the file to a directory and clean up
	// files older than a day every hour in a background (e.g. cron) job.
	//
	// Cluster implementations might write the file to a shared network directory
	// (most pragmatic/common), introduce an custom disk abstraction layer (most
	// elegant?) or stickily load-balance via a proxy job (only listed for
	// completeness as it limits build throughput).
	//
	// Cloud implementations might write the file to a key/value store with a TTL
	// of one day.
	//
	// Files are transferred as a stream of chunks with size 4096 bytes.
	Store(Build_StoreServer) error
	// Build ensures the specified input_path are available in the current working
	// directory, changes into working_directory, then runs a distri build with
	// any additional build_flag specified.
	//
	// Build output artifacts paths are streamed in BuildProgress messages.
	Build(*BuildRequest, Build_BuildServer) error
	// Retrieve streams the file located at path in chunks of size 4096 bytes.
	Retrieve(*RetrieveRequest, Build_RetrieveServer) error
}

func RegisterBuildServer(s *grpc.Server, srv BuildServer) {
	s.RegisterService(&_Build_serviceDesc, srv)
}

func _Build_Store_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BuildServer).Store(&buildStoreServer{stream})
}

type Build_StoreServer interface {
	SendAndClose(*StoreResponse) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type buildStoreServer struct {
	grpc.ServerStream
}

func (x *buildStoreServer) SendAndClose(m *StoreResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *buildStoreServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Build_Build_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BuildRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuildServer).Build(m, &buildBuildServer{stream})
}

type Build_BuildServer interface {
	Send(*BuildProgress) error
	grpc.ServerStream
}

type buildBuildServer struct {
	grpc.ServerStream
}

func (x *buildBuildServer) Send(m *BuildProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _Build_Retrieve_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RetrieveRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuildServer).Retrieve(m, &buildRetrieveServer{stream})
}

type Build_RetrieveServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type buildRetrieveServer struct {
	grpc.ServerStream
}

func (x *buildRetrieveServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

var _Build_serviceDesc = grpc.ServiceDesc{
	ServiceName: "builder.Build",
	HandlerType: (*BuildServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Store",
			Handler:       _Build_Store_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Build",
			Handler:       _Build_Build_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Retrieve",
			Handler:       _Build_Retrieve_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "builder.proto",
}
